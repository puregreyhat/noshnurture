import { NextResponse } from "next/server";
import { generateSuggestions } from "@/lib/recipes/generator";
import { normalizeIngredientName } from "@/lib/ingredients/normalize";
import { createClient } from "@/lib/supabase/server";

export const revalidate = 0; // dynamic, don't cache at edge by default

// Helper function to determine cuisine based on recipe title
function determineCuisineFromTitle(title: string): string {
  const titleLower = title.toLowerCase();
  
  // Indian/South Indian indicators
  if (titleLower.includes('curry') || titleLower.includes('masala') || 
      titleLower.includes('dosa') || titleLower.includes('idli') || 
      titleLower.includes('sambar') || titleLower.includes('rasam') ||
      titleLower.includes('biryani') || titleLower.includes('dal') ||
      titleLower.includes('tandoori') || titleLower.includes('naan') ||
      titleLower.includes('uttapam')) {
    return 'Indian';
  }
  
  // East Asian indicators
  if (titleLower.includes('stir-fry') || titleLower.includes('stir fry') ||
      titleLower.includes('fried rice') || titleLower.includes('soy') ||
      titleLower.includes('wok') || titleLower.includes('noodles')) {
    return 'East Asian';
  }
  
  // Italian indicators
  if (titleLower.includes('pasta') || titleLower.includes('pizza') ||
      titleLower.includes('risotto') || titleLower.includes('pesto') ||
      titleLower.includes('polenta') || titleLower.includes('Italian')) {
    return 'Italian';
  }
  
  // European indicators
  if (titleLower.includes('roasted') || titleLower.includes('traybake') ||
      titleLower.includes('steak') || titleLower.includes('schnitzel') ||
      titleLower.includes('european')) {
    return 'European';
  }
  
  // Default to International
  return 'International';
}

async function getExpiringIngredients(items: Record<string, unknown>[]): Promise<string[]> {
  const expiring = items.filter(i => typeof i.days_until_expiry === 'number' && i.days_until_expiry >= 0 && i.days_until_expiry <= 7);
  const canonicals = new Set<string>();
  for (const item of expiring) {
    const tags = Array.isArray(item.tags) ? item.tags : [];
    const canonical = tags.find((t: unknown) => typeof t === 'string' && t.startsWith("canonical:"))?.toString().replace(/^canonical:/, "");
    if (canonical) {
      canonicals.add(canonical);
    } else {
      try {
        const c = await normalizeIngredientName(String(item.product_name || ''));
        canonicals.add(c);
      } catch {
        // ignore
      }
    }
  }
  return Array.from(canonicals).slice(0, 6);
}

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const source = (url.searchParams.get('source') || 'spoonacular').toString()
    const showAll = url.searchParams.get('all') === 'true';
    
    // Get authenticated user
    const supabaseServer = await createClient();
    const { data: { user }, error: authError } = await supabaseServer.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userId = user.id;
    const { data, error } = await supabaseServer
      .from("inventory_items")
      .select("*")
      .eq("user_id", userId)
      .eq("is_consumed", false);

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    const items = data || [];
    
    console.log(`[Recipes API] Found ${items.length} inventory items`);
    console.log(`[Recipes API] showAll=${showAll}, source=${source}`);
    
    // If no items, return empty immediately
    if (items.length === 0) {
      console.log('[Recipes API] No inventory items, returning empty suggestions');
      return NextResponse.json({ suggestions: [] });
    }
    
    // Generate template-based suggestions (fast, always available)
    const templateSuggestions = await generateSuggestions(items);
    console.log(`[Recipes API] Generated ${templateSuggestions.length} template suggestions`);
    
  // Optionally fetch Spoonacular suggestions for variety (DEPRECATED)
  // We intentionally do not call Spoonacular for now to avoid API limits.
  const expiringIngredients = await getExpiringIngredients(items);
  // If client asked to use our Sugran recipe service, proxy inventory and return those suggestions
    if (source === 'sugran' || source === 'recipes-site') {
      try {
        const SUGRAN = process.env.SUGRAN_URL || process.env.RECIPES_SITE_URL || 'https://sugran.vercel.app';
        
        // If showAll is true, fetch the full recipe list directly instead of searching
        if (showAll) {
          console.log('[Recipes API] "showAll=true" - fetching full Sugran recipe list with matched data');
          try {
            const listResp = await fetch(`${SUGRAN.replace(/\/$/, '')}/api/recipes`);
            if (listResp.ok) {
              const lj = await listResp.json();
              const listArr = Array.isArray(lj) ? lj : Array.isArray(lj.results) ? lj.results : (Array.isArray(lj.recipes) ? lj.recipes : []);
              console.log(`[Recipes API] Fetched ${listArr.length} recipes from full Sugran list`);
              
              const allMapped = listArr.map((recRaw: unknown) => {
                const rec = recRaw as Record<string, unknown>;
                const title = String((rec.name ?? rec.title ?? 'Untitled') as unknown);
                const image = String((rec.image ?? rec.image_url ?? (rec as any).imageUrl ?? '') as unknown);
                const id = rec.id ? `sugran-${String(rec.id)}` : `sugran-${encodeURIComponent(title).toLowerCase()}`;
                const matched = typeof rec.matched === 'number' ? (rec.matched as number) : (Array.isArray(rec.matched) ? (rec.matched as unknown[]) : []);
                const missing = Array.isArray(rec.missing) ? (rec.missing as unknown[]) : [];
                
                // Extract cuisine from recipe or infer from title
                let cuisine = String((rec.cuisine ?? '') as unknown).trim();
                if (!cuisine) {
                  cuisine = determineCuisineFromTitle(title);
                }
                
                const matchedCount = Array.isArray(matched) ? matched.length : typeof matched === 'number' ? matched : 0;
                const totalCount = (Array.isArray(matched) ? matched.length : 0) + (Array.isArray(missing) ? missing.length : 0);
                
                return {
                  title,
                  image,
                  id,
                  source: 'sugran',
                  matched,
                  missing,
                  cuisine,
                  matchedIngredientCount: matchedCount,
                  totalIngredientCount: totalCount,
                };
              });
              
              // Sort by availability ratio (matched/total) - highest percentage first!
              const sorted = allMapped.sort((a: typeof allMapped[0], b: typeof allMapped[0]) => {
                const aMatched = a.matchedIngredientCount ?? 0;
                const aTotal = a.totalIngredientCount ?? 1;
                const bMatched = b.matchedIngredientCount ?? 0;
                const bTotal = b.totalIngredientCount ?? 1;
                
                // Calculate availability percentage
                const aRatio = aMatched / aTotal;
                const bRatio = bMatched / bTotal;
                
                // Sort by ratio (descending) - highest percentage first
                const diff = bRatio - aRatio;
                console.log(`[Recipes API] Sorting: ${a.title}(${aMatched}/${aTotal}=${(aRatio*100).toFixed(0)}%) vs ${b.title}(${bMatched}/${bTotal}=${(bRatio*100).toFixed(0)}%) = ${diff}`);
                return diff;
              });
              console.log(`[Recipes API] Sorted recipes: ${sorted.map((r: typeof sorted[0]) => `${r.title}(${r.matchedIngredientCount}/${r.totalIngredientCount}=${((r.matchedIngredientCount/(r.totalIngredientCount||1))*100).toFixed(0)}%)`).join(', ')}`);
              return NextResponse.json({ suggestions: sorted });
            }
          } catch (e) {
            console.error('[Recipes API] Error fetching full list:', (e as Error).message);
            // Fallback below
          }
        }
        
        // Regular search path (not showAll)
        // Build simple inventory array of product names
        const inventoryNames: string[] = (items || [])
          .slice(0, 100)
          .map(it => String(it.product_name || it.name || '').trim())
          .filter(Boolean);

        // prefer more items from Sugran; request up to desiredCount
        const desiredCount = 12;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 4000);
        console.log('[Recipes API] Making search request to Sugran with inventory:', inventoryNames.slice(0, 5));
        const resp = await fetch(`${SUGRAN.replace(/\/$/, '')}/api/recipes/search`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ inventory: inventoryNames, limit: desiredCount }),
          signal: controller.signal,
        });
        clearTimeout(timeoutId);
        if (resp.ok) {
          const j = await resp.json();
          const resultsArr = Array.isArray(j.results) ? (j.results as unknown[]) : [];
          console.log(`[Recipes API] Search returned ${resultsArr.length} results`);
          const mapped = resultsArr.map((r) => {
            const rObj = r as Record<string, unknown>;
            const recipe = (rObj.recipe as Record<string, unknown>) ?? (rObj as Record<string, unknown>);
            const title = String((recipe.name ?? recipe.title ?? 'Untitled') as unknown);
            const image = String((recipe.image ?? recipe.image_url ?? (recipe as any).imageUrl ?? '') as unknown);
            // Make id path-safe and indicate origin
            const id = recipe.id ? `sugran-${String(recipe.id)}` : `sugran-${encodeURIComponent(title).toLowerCase()}`;
            const matched = typeof rObj.matched === 'number' ? (rObj.matched as number) : (Array.isArray(rObj.matched) ? (rObj.matched as unknown[]) : []);
            const missing = Array.isArray(rObj.missing) ? (rObj.missing as unknown[]) : [];
            
            // Extract cuisine from Sugran recipe or infer from title
            let cuisine = String((recipe.cuisine ?? '') as unknown).trim();
            if (!cuisine) {
              cuisine = determineCuisineFromTitle(title);
            }
            
            // Calculate matched ingredient count
            const matchedCount = Array.isArray(matched) ? matched.length : typeof matched === 'number' ? matched : 0;
            const missingCount = Array.isArray(missing) ? missing.length : 0;
            const totalCount = matchedCount + missingCount;
            
            console.log(`[Recipes API] Search recipe: ${title} - matched: ${matchedCount}, total: ${totalCount}`);
            
            return {
              title,
              image,
              id,
              source: 'sugran',
              matched,
              missing,
              cuisine,
              matchedIngredientCount: matchedCount,
              totalIngredientCount: totalCount,
            };
          });
          try { console.log('[Recipes API] mapped sugran suggestion ids:', mapped.map(m => m.id)); } catch {}

          // If Sugran returned fewer than desiredCount, try to fetch the full recipe list as a fallback
          let finalMapped = mapped.slice();
          if (finalMapped.length < desiredCount) {
            try {
              const listResp = await fetch(`${SUGRAN.replace(/\/$/, '')}/api/recipes`);
              if (listResp.ok) {
                const lj = await listResp.json();
                const listArr = Array.isArray(lj) ? lj : Array.isArray(lj.results) ? lj.results : (Array.isArray(lj.recipes) ? lj.recipes : []);
                for (const recipeRaw of listArr) {
                  if (finalMapped.length >= desiredCount) break;
                  const rec = recipeRaw as Record<string, unknown>;
                  const title = String((rec.name ?? rec.title ?? 'Untitled') as unknown);
                  const image = String((rec.image ?? rec.image_url ?? (rec as any).imageUrl ?? '') as unknown);
                  const id = rec.id ? `sugran-${String(rec.id)}` : `sugran-${encodeURIComponent(title).toLowerCase()}`;
                  // avoid duplicates by id
                  if (!finalMapped.find(m => m.id === id)) {
                    let cuisine = String((rec.cuisine ?? '') as unknown).trim();
                    if (!cuisine) {
                      cuisine = determineCuisineFromTitle(title);
                    }
                    finalMapped.push({
                      title,
                      image,
                      id,
                      source: 'sugran',
                      matched: [],
                      missing: [],
                      cuisine,
                      matchedIngredientCount: 0,
                      totalIngredientCount: 0,
                    });
                  }
                }
              }
            } catch (e) {
              // ignore list fetch errors
            }
          }

          // If client asked for 'all' (UI uses this when user toggles), and Sugran returned fewer than desiredCount,
          // return the fullSugran list (unpaginated) so UI can display all recipes from Sugran.
          if (url.searchParams.get('all') === 'true') {
            console.log('[Recipes API] "all=true" requested - fetching full recipe list');
            try {
              const listResp = await fetch(`${SUGRAN.replace(/\/$/, '')}/api/recipes`);
              if (listResp.ok) {
                const lj = await listResp.json();
                const listArr = Array.isArray(lj) ? lj : Array.isArray(lj.results) ? lj.results : (Array.isArray(lj.recipes) ? lj.recipes : []);
                console.log(`[Recipes API] Fetched ${listArr.length} recipes from full list`);
                const allMapped = listArr.map((recRaw: unknown) => {
                  const rec = recRaw as Record<string, unknown>;
                  const title = String((rec.name ?? rec.title ?? 'Untitled') as unknown);
                  const image = String((rec.image ?? rec.image_url ?? (rec as any).imageUrl ?? '') as unknown);
                  const id = rec.id ? `sugran-${String(rec.id)}` : `sugran-${encodeURIComponent(title).toLowerCase()}`;
                  const matched = typeof rec.matched === 'number' ? (rec.matched as number) : (Array.isArray(rec.matched) ? (rec.matched as unknown[]) : []);
                  const missing = Array.isArray(rec.missing) ? (rec.missing as unknown[]) : [];
                  
                  // Extract cuisine from recipe or infer from title
                  let cuisine = String((rec.cuisine ?? '') as unknown).trim();
                  if (!cuisine) {
                    cuisine = determineCuisineFromTitle(title);
                  }
                  
                  const matchedCount = Array.isArray(matched) ? matched.length : typeof matched === 'number' ? matched : 0;
                  const totalCount = (Array.isArray(matched) ? matched.length : 0) + (Array.isArray(missing) ? missing.length : 0);
                  console.log(`[Recipes API] Full list recipe: ${title} - matched: ${matchedCount}, total: ${totalCount}`);
                  
                  return {
                    title,
                    image,
                    id,
                    source: 'sugran',
                    matched,
                    missing,
                    cuisine,
                    matchedIngredientCount: matchedCount,
                    totalIngredientCount: totalCount,
                  };
                });
                
                // Sort by availability ratio (matched/total) - highest percentage first!
                console.log('[Recipes API] Before sort:', allMapped.map((r: typeof allMapped[0]) => `${r.title}(${r.matchedIngredientCount}/${r.totalIngredientCount})`).join(', '));
                const sorted = allMapped.sort((a: typeof allMapped[0], b: typeof allMapped[0]) => {
                  const aMatched = a.matchedIngredientCount ?? 0;
                  const aTotal = a.totalIngredientCount ?? 1;
                  const bMatched = b.matchedIngredientCount ?? 0;
                  const bTotal = b.totalIngredientCount ?? 1;
                  
                  // Calculate availability percentage
                  const aRatio = aMatched / aTotal;
                  const bRatio = bMatched / bTotal;
                  
                  // Sort by ratio (descending) - highest percentage first
                  return bRatio - aRatio;
                });
                console.log('[Recipes API] After sort:', sorted.map((r: typeof sorted[0]) => `${r.title}(${r.matchedIngredientCount}/${r.totalIngredientCount}=${((r.matchedIngredientCount/(r.totalIngredientCount||1))*100).toFixed(0)}%)`).join(', '));
                return NextResponse.json({ suggestions: sorted });
              }
            } catch (e) {
              console.error('[Recipes API] Error fetching full list:', (e as Error).message);
              // fallback to merged if list fetch failed
            }
          }

          // Merge and sort: template suggestions + sugran recipes (already enhanced)
          const merged = [...templateSuggestions, ...finalMapped]
            .sort((a, b) => {
              // Get matched/total counts (works for both template and sugran recipes)
              const aMatched = (a as any).matchedIngredientCount ?? 0;
              const aTotal = (a as any).totalIngredientCount ?? 1;
              const bMatched = (b as any).matchedIngredientCount ?? 0;
              const bTotal = (b as any).totalIngredientCount ?? 1;
              
              // Calculate availability percentage (matched/total)
              const aRatio = aMatched / aTotal;
              const bRatio = bMatched / bTotal;
              
              // Sort by ratio (descending) - highest percentage first!
              const ratioDiff = bRatio - aRatio;
              if (ratioDiff !== 0) return ratioDiff;
              
              // For score, only template suggestions have it; sugran recipes don't
              const aScore = (a as any).score ?? 0;
              const bScore = (b as any).score ?? 0;
              const scoreDiff = bScore - aScore;
              if (scoreDiff !== 0) return scoreDiff;
              
              // For time, only template suggestions have it; sugran recipes don't
              const aTime = (a as any).totalTime ?? 0;
              const bTime = (b as any).totalTime ?? 0;
              return aTime - bTime;
            })
            .slice(0, desiredCount);
          
          return NextResponse.json({ suggestions: merged });
        }
      } catch (e) {
        console.error('[Recipes API] sugran proxy failed, falling back to templates', (e as Error).message)
      }
    }
    // We don't call Spoonacular right now. Return template suggestions only by default.
    const merged = [...templateSuggestions].slice(0, 8);
    
    console.log(`[Recipes API] Returning ${merged.length} total suggestions`);
  return NextResponse.json({ suggestions: merged });
  } catch (e) {
    console.error('[Recipes API] Error:', e);
    const err = e as Error
    return NextResponse.json({ error: err?.message || "Unknown error" }, { status: 500 });
  }
}
